## 6.1 编写 RESTful 控制器

当翻页并阅读本章的介绍时，Taco Cloud 的用户界面已经被重新设计了。一直在做的事情在开始的时候是可以的，但是在美学方面却有欠缺。

图 6.1 只是新的 Taco Cloud 的一个示例，很时髦的，不是吗？

**图 6.1 新的 Taco Cloud 主页**

 ![图 6.1 新的 Taco Cloud 主页](E:\Document\spring-in-action-v5-translate\第二部分 集成 Spring\第 6 章 创建 REST 服务\图 6.1 新的 Taco Cloud 主页.jpg)

在我对 Taco Cloud 外观进行改进的同时，我还决定使用流行的 Angular 框架将前端构建为一个单页应用程序。最终，这个新的浏览器 UI 将取代在第 2 章中创建的服务器渲染页面。但要实现这一点，需要创建一个 REST API，基于 Angular 的 UI 将与之通信，以保存和获取 taco 数据。

> 用 SPA 还是不用？
>
> 在第 2 章中，使用 Spring MVC 开发了一个传统的多页面应用程序（MPA），现在将用一个基于 Angular 的单页面应用程序（SPA）取代它，但并不总是说 SPA 是比 MPA 更好的选择。
>
> 由于呈现在很大程度上与 SPA 中的后端处理解耦，因此可以为相同的后端功能开发多个用户界面（例如本机移动应用程序）。它还提供了与其他可以使用 API 的应用程序集成的机会。但并不是所有的应用程序都需要这种灵活性，如果只需要在 web 页面上显示信息，那么 MPA 是一种更简单的设计。

这不是一本关于 Angular 的书，所以这一章的代码主要着重于后端的 Spring 代码。我将展示足够多的 Angular 代码，让你了解客户端是如何工作的。请放心，完整的代码集，包括 Angular 前端，都可以作为可下载代码的一部分，在 https://github.com/habuma/springing-inaction-5-samples 中找到。你可能还会对 Jeremy Wilken（2018 年传）的《Angular 实战》以及 Yakov Fain 和 Anton Moiseev（2018 年出版）合著的《基于 TypeScript 的 Angular 开发（第二版）》感兴趣。

简而言之，Angular 客户端代码将通过 HTTP 请求的方式与本章中创建的 API 进行通信。在第 2 章中，使用 @GetMapping 和 @PostMapping 注解来获取和发送数据到服务器。在定义 REST API 时，这些相同的注释仍然很有用。此外，Spring MVC 还为各种类型的 HTTP 请求支持少量其他注解，如表 6.1 所示。

**表 6.1 Spring MVC HTTP 请求处理注解**

| 注解            | HTTP 方法        | 典型用法     |
| --------------- | ---------------- | ------------ |
| @GetMapping     | HTTP GET 请求    | 读取资源数据 |
| @PostMapping    | HTTP POST 请求   | 创建资源     |
| @PutMapping     | HTTP PUT 请求    | 更新资源     |
| @PatchMapping   | HTTP PATCH 请求  | 更新资源     |
| @DeleteMapping  | HTTP DELETE 请求 | 删除资源     |
| @RequestMapping | 通用请求处理     |              |

要查看这些注释的实际效果，将首先创建一个简单的 REST 端点，该端点获取一些最近创建的 taco。

### 6.1.1 从服务器获取数据

Taco Cloud 最酷的事情之一是它允许 Taco 狂热者设计他们自己的 Taco 作品，并与他们的 Taco 爱好者分享。为此，Taco Cloud 需要能够在单击最新设计链接时显示最近创建的 Taco 的列表。

在 Angular 代码中，我定义了一个 RecentTacosComponent，它将显示最近创建的 tacos。RecentTacosComponent 的完整 TypeScript 代码在下面程序清单中。程序清单 6.1 展示最近 taco 的 Angular 组件

```typescript
import { Component, OnInit, Injectable } from '@angular/core';
import { Http } from '@angular/http';
import { HttpClient } from '@angular/common/http';

@Component({
    selector: 'recent-tacos',
    templateUrl: 'recents.component.html',
    styleUrls: ['./recents.component.css']
})

@Injectable()
export class RecentTacosComponent implements OnInit {
    recentTacos: any;
    
    constructor(private httpClient: HttpClient) { }
    
    ngOnInit() {
        this.httpClient.get('http://localhost:8080/design/recent')
            .subscribe(data => this.recentTacos = data);
    }
}
```

请注意 ngOnInit() 方法，在该方法中，RecentTacosComponent 使用注入的 Http 模块执行对 http://localhost:8080/design/recent 的 Http GET 请求，期望响应将包含 taco 设计的列表，该列表将放在 recentTacos 模型变量中。视图（在 recents.component.HTML 中）将模型数据以 HTML 的形式呈现在浏览器中。在创建了三个 tacos 之后，最终结果可能类似于图 6.2。

**图 6.2 显示最近创建的 tacos**

![图 6.2 显示最近创建的 tacos](E:\Document\spring-in-action-v5-translate\第二部分 集成 Spring\第 6 章 创建 REST 服务\图 6.2 显示最近创建的 tacos.jpg)

这个版面中缺失的部分是一个端点，它处理 `/design/recent` 接口的 GET 请求 ，并使用一个最新设计的 taco 列表进行响应。后面将创建一个新的控制器来处理这样的请求，下面的程序清单显示了怎么去做的。程序清单 6.2 taco 设计 API 请求的 RESTful 控制器

```java
package tacos.web.api;

import java.util.Optional;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Sort;
import org.springframework.hateoas.EntityLinks;
import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseStatus;
import org.springframework.web.bind.annotation.RestController;

import tacos.Taco;
import tacos.data.TacoRepository;

@RestController
@RequestMapping(path="/design", produces="application/json")
@CrossOrigin(origins="*")
public class DesignTacoController {
    
    private TacoRepository tacoRepo;
    
    @Autowired
    EntityLinks entityLinks;
    
    public DesignTacoController(TacoRepository tacoRepo) {
        this.tacoRepo = tacoRepo;
    }
    
    @GetMapping("/recent")
    public Iterable<Taco> recentTacos() {
        PageRequest page = PageRequest.of(
            0, 12, Sort.by("createdAt").descending());
        return tacoRepo.findAll(page).getContent();
    }
}
```

你可能认为这个控制器的名字听起来很熟悉。在第 2 章中，创建了一个处理类似类型请求的 DesignTacoController。但是这个控制器是用于多页面 Taco Cloud 应用程序的，正如 @RestController 注解所示，这个新的 DesignTacoController 是一个 REST 控制器。

@RestController 注解有两个用途。首先，它是一个像 @Controller 和 @Service 这样的原型注解，它通过组件扫描来标记一个类。但是与 REST 的讨论最相关的是，@RestController 注解告诉 Spring，控制器中的所有处理程序方法都应该将它们的返回值直接写入响应体，而不是在模型中被带到视图中进行呈现。

或者，可以使用 @Controller 来注解 DesignTacoController，就像使用任何 Spring MVC 控制器一样。但是，还需要使用 @ResponseBody 注解所有处理程序方法，以获得相同的结果。另一个选项是返回一个 ResponseEntity 对象，我们稍后将讨论它。

类级别的 @RequestMapping 注解与 recentTacos() 方法上的 @GetMapping 注解一起工作，以指定 recentTacos() 方法负责处理 `/design/recent` 接口的 GET 请求（这正是 Angular 代码所需要的）。

注意，@RequestMapping 注解还设置了一个 produces 属性。这指定了 DesignTacoController 中的任何处理程序方法只在请求的 Accept 头包含 “application/json” 时才处理请求。这不仅限制了 API 只生成 JSON 结果，还允许另一个控制器（可能是第 2 章中的 DesignTacoController）处理具有相同路径的请求，只要这些请求不需要 JSON 输出。尽管这将 API 限制为基于 JSON 的，但是欢迎将 produces 设置为多个内容类型的字符串数组。例如，为了允许 XML 输出，可以向 produces 属性添加 “text/html”：

```java
@RequestMapping(path="/design", produces={"application/json", "text/xml"})
```

在程序清单 6.2 中可能注意到的另一件事是，该类是用 @CrossOrigin 注解了的。由于应用程序的 Angular 部分将运行在独立于 API 的主机或端口上（至少目前是这样），web 浏览器将阻止 Angular 客户端使用 API。这个限制可以通过在服务器响应中包含 CORS（跨源资源共享）头来克服。Spring 使得使用 @CrossOrigin 注解应用 CORS 变得很容易。正如这里所应用的，@CrossOrigin 允许来自任何域的客户端使用 API。

recentTacos() 方法中的逻辑相当简单。它构造了一个 PageRequest 对象，该对象指定只想要12个结果的第一个(第0个)页面，按照taco的创建日期降序排序。简而言之，你想要一打最新设计的墨西哥玉米卷。PageRequest被传递到TacoRepository的findAll()方法的调用中，结果页面的内容被返回给客户机(如清单6.1所示，它将作为模型数据显示给用户)。

现在，假设您希望提供一个端点，该端点通过其ID获取单个taco。通过在处理程序方法的路径中使用占位符变量并接受path变量，您可以捕获该ID并使用它通过存储库查找taco对象:













